---
title: "Comparison of TSSSE model and BiSSE"
author: "Heath Blackmon"
date: "December 20, 2015"
output: 
  html_document:
    theme: cosmo
    toc: true
    toc_depth: 2
---

# Introduction

This page summarizes the results of preliminary testing of the TSSSE model.  This model represents a biological case where we have binary trait where transition into the derived state causes a different diversification rate.  However this effect is limited to a short time period, eventually the derived state will return to the diversification rate that the ancestral state exhibited.

# Simulation and Testing

As the very first test of this approach we would like to make sure that when we simulate under this model we are able to recover the simulating model/parameters.  To do this we will simulate the underlying data with this code:

```{}
library(diversitree)
musse.data <- vector(mode="list", length=100)
pars <- c(0.10, 0.20, 0.10,  # lambda 1, 2, 3
          0.01, 0.01, 0.01,  # mu 1, 2, 3
          0.01, 0.00,        # q12, q13
          0.00, 0.05,        # q21, q23
          0.00, 0.00)        # q31, q32
for(i in 1:100){
  check <- F
  while(check == F){
    print(i)
    foo <- tree.musse(pars, max.taxa = 200, x0 = 1)
    if(sum(foo$tip.state == 1) > 30 & sum(foo$tip.state == 1) < 170) check <- T
  }
  musse.data[[i]] <- foo
}
```

This data will work for our purposes and represents a case where the transition results in only a relativeley small change in diversification (relative to the types of differences in diversification that are often inferred in emprical studies).  The one caveat is that currently it has 3 character states we will need to collapse states 2 and 3 into a single state (the derived state discussed above.)  This code will do this for us:

```{}
for(i in 1:100){
  musse.data[[i]]$tip.state[musse.data[[i]]$tip.state == 3] <- 2
}
```

Now we want to analyze this data with our new model TSSSE but also for comparison purposes lets also analyze under the traditional BiSSE model.  First we will do the simple analysis assuming the BiSSE model:

```{}
pars <- c(0.10, 0.10,  # lambda 1, 2
          0.01, 0.01,  # mu 1, 2
          0.01, 0.01)  # q12, q21
test.res <- vector()
for(i in 1:100){
  # we have to include the -1 below to deal with the fact 
  # that BiSSE expects 0 and 1 not 1 and 2
  BIS.lik <- make.bisse(musse.data[[i]], musse.data[[i]]$tip.state-1)
  BIS.lik.c <- constrain(BIS.lik, lambda0 ~ lambda1)
  fit <- find.mle(BIS.lik, pars)
  fit.l <- find.mle(BIS.lik.c, pars[c(1,3:6)])
  test.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
  # print(i)
}
hist(test.res, xlab="P-value", main="Prob. of TSSSE data \ngiven BiSSE model")
```

Now we can go ahead and do the analysis assuming the TSSSE model.  We need to convert our binary state character with states 1 and 2 into a matrix where each species has a defined probability of being in states 1, 2a, or 2b.  All species observed as being in state 1 will have a probability of 1 for state 1 and 0 for all other states.  Species in state 2 will have a proability of 0 for state 1 and a probability of 1 for both states 2a and 2b.

```{}
test.res2 <- vector()
for(i in 1:100){
  print(i)
  # this is the matrix setup part
  data.mat <- matrix(0,200,3)
  data.mat[musse.data[[i]]$tip.state == 1, 1] <- 1
  data.mat[musse.data[[i]]$tip.state == 2, 2] <- 1
  data.mat[musse.data[[i]]$tip.state == 2, 3] <- 1
  row.names(data.mat) <- names(musse.data[[i]]$tip.state)
  # now we can analyze under the TSSSE model by using a constrained version
  # of the MUSSE model implemented in diversitree
  MUSS.lik <- make.musse(musse.data[[i]], states=data.mat, strict=F, k=3)  
  TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, 
                       q13 ~ 0, q21 ~ 0, 
                       q31 ~ 0, q32 ~ 0)
  TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3, 
                        q13 ~ 0, q21 ~ 0, 
                        q31 ~ 0, q32 ~ 0)
  pars <- c(0.10, 0.10,    # lambda 2, 3
          0.01, 0.01, 0.01,# mu 1, 2, 3
          0.01,            # q12
          0.05)            # q23
  print("fitting full model")        
  fit <- find.mle(TSS.lik, pars)
  print("fitting constrained model")        
  fit.l <- find.mle(TSS.likl, pars[c(1,3:7)])
  test.res2[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
hist(test.res2, xlab="P-value", main="Prob. of TSSSE data \ngiven TSSSE model")
foo <- test.res2[!is.na(test.res2)]
sum(foo <= .05)/length(foo) * 100
```


We should make sure that we don't get anything weird when we simulate data with all equal rates.

```{}
null.data <- vector(mode="list", length=100)
pars <- c(0.10, 0.10, 0.10,  # lambda 1, 2, 3
          0.01, 0.01, 0.01,  # mu 1, 2, 3
          0.01, 0.00,        # q12, q13
          0.00, 0.05,        # q21, q23
          0.00, 0.00)        # q31, q32
for(i in 1:100){
  check <- F
  while(check ==F){
    print(i)
    foo <- tree.musse(pars, max.taxa=200, x0=1)
    if(sum(foo$tip.state==1) > 30 & sum(foo$tip.state==1) < 170) check <- T
  }
  null.data[[i]] <- foo
}
# Now we need a litt bit of code to convert the 
# three states above two just two states that we actually observe:
for(i in 1:100){
  null.data[[i]]$tip.state[null.data[[i]]$tip.state == 3] <- 2
}
```

Now we want to analyze this data under BiSSE model:

```{}
pars <- c(0.10, 0.10,  # lambda 1, 2
          0.01, 0.01,  # mu 1, 2
          0.01, 0.01)  # q12, q21
test.res <- vector()
for(i in 1:100){
  BIS.lik <- make.bisse(null.data[[i]], null.data[[i]]$tip.state-1)
  BIS.lik.c <- constrain(BIS.lik, lambda0 ~ lambda1)
  fit <- find.mle(BIS.lik, pars)
  fit.l <- find.mle(BIS.lik.c, pars[c(1,3:6)])
  test.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
  print(i)
}
test.res2 <- vector()
for(i in 70:100){
  print(i)
  data.mat <- matrix(0,200,3)
  data.mat[null.data[[i]]$tip.state == 1, 1] <- 1
  data.mat[null.data[[i]]$tip.state == 2, 2] <- 1
  data.mat[null.data[[i]]$tip.state == 2, 3] <- 1
  row.names(data.mat) <- names(null.data[[i]]$tip.state)
  MUSS.lik <- make.musse(null.data[[i]], states=data.mat, strict=F, k=3)  
  TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0, 
                       q31 ~ 0, q32 ~ 0)
  TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3, 
                        q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0)
  pars <- c(0.10, 0.10,    # lambda 2, 3
          0.01, 0.01, 0.01,# mu 1, 2, 3
          0.01,            # q12
          0.05)            # q23
  print("fitting full model")        
  fit <- find.mle(TSS.lik, pars)
  print("fitting constrained model")        
  fit.l <- find.mle(TSS.likl, pars[c(1,3:7)])
  test.res2[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
```

The next thing to do is to look at what happens when we model a neutral binary trait on a tree that has variation in diversification.  For this we will use the same whale tree that Emma and Dan used in their paper.  Like we did above we will condition our simulations on having at least some taxa in each state.  Based on previous work with BiSSE we should se a high false positive rate here.

```{}
setwd("~/Desktop/TSSSE")
tree <- read.tree("whales.tre")
library(geiger)
tree <- rescale(tree, model="depth", depth=1)
q <- list(rbind(c(-.2, .2, .0), 
                c(.0, -.9, .9), 
                c(.0, .0, .0)))
foo <- sim.char(tree, q, model="discrete", n=400)[,1,]
# We simulated 400 datasets lets just pull out 100 that have a good mix of states
check <- vector()
for(i in 1:400){
  check[i] <- sum(foo[,i]==1) < 70 & sum(foo[,i]==1) > 10 
}
foo <- foo[,which(check)[1:100]]
# and we will rename something sensible
neut.data <- foo
```

Now we need a litt bit of code to convert the three states above two just two states that we actually observe:
```{}
for(i in 1:100){
  neut.data[, i][neut.data[, i] == 3] <- 2
}
```

Next we will analyze this data under both BiSSE and TSSSE.

First BiSSE

```{}
pars <- c(0.10, 0.10,  # lambda 1, 2
          0.01, 0.01,  # mu 1, 2
          0.01, 0.01)  # q12, q21
bis.W.res <- vector()
for(i in 1:100){
  BIS.lik <- make.bisse(tree, neut.data[,i]-1)
  BIS.lik.c <- constrain(BIS.lik, lambda0 ~ lambda1)
  fit <- find.mle(BIS.lik, pars)
  fit.l <- find.mle(BIS.lik.c, pars[c(1,3:6)])
  bis.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
  print(i)
}
```


Next TSSSE

```{}
tss.W.res <- vector()

for(i in 100:100){
  print(i)
  data.mat <- matrix(0,87,3)
  data.mat[neut.data[,i] == 1, 1] <- 1
  data.mat[neut.data[,i] == 2, 2] <- 1
  data.mat[neut.data[,i] == 2, 3] <- 1
  row.names(data.mat) <- row.names(neut.data)
  MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)  
  TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0, 
                       q31 ~ 0, q32 ~ 0)
  TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3, 
                        q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0)
  pars <- c(1, 1,    # lambda 2, 3
          0.01, 0.01, 0.01,# mu 1, 2, 3
          0.1,            # q12
          0.5)            # q23
  print("fitting full model")        
  fit <- find.mle(TSS.lik, pars)
  print("fitting constrained model")        
  fit.l <- find.mle(TSS.likl, pars[c(1,3:7)])
  tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
```



# Results

So a note here the constrained version of the TSSSE model does give the find.mle function a bit of trouble.  The failures are of two varieties: one is where the constrained model is more likely than the unconstrained model indicating a failure to find a global optimum; in the second case we have some runs that just get stuck and never drop out of the optimization.  The results that are presented below are from those datasets where the find.mle fucntion appeared to successfuly find a global optimum.

Because the simulations here take quite a while to run we will load the results from the first time that I ran these scripts.
```{r}
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv", row.names = 1)
```


&nbsp;

&nbsp;


First we can look at the power of this approach:
```{r, fig.cap="__Assesment of power when just after transition diversification is twice the background rate. Generating model TSSSE and inference model TSSSE.__", echo = F}
hist(data[, 2], main = "", 
     breaks = 20, xlab = "p-value from LRT",
     col = c("red", rep("black", 19)))
text(.5, 30, paste(round(sum(data[1:77, 2]<=.05)/77*100), "% Significant", sep=""))
```

We can also compare this to what happens when we analyze this same dataset assuming the BiSSE model.
```{r, fig.cap="__Assesment of power when just after transition diversification is twice the background rate. Generating model TSSSE and inference model BiSSE.__", echo = F}
hist(data[, 1], main = "", 
     breaks = 20, xlab = "p-value from LRT",
     col = c("red", rep("black", 19)))
text(.5, 40, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep=""))
```

&nbsp;

&nbsp;

Next lets see what happens when the trait is neutral with no effect on diversification.
```{r, fig.cap="__Assesment of type 1 error rate. Generating model TSSSE and inference model TSSSE.__", echo = F}
hist(data[, 3], main = "", 
     breaks = 20, xlab = "p-value from LRT",
     col = c("red", rep("black", 19)))
text(.475, 8, paste(round(sum(data[1:86, 3]<=.05)/86*100), "% Significant", sep=""))
```

Next lets see what happens when the trait is neutral with no effect on diversification.
```{r, fig.cap="__Assesment of type 1 error rate. Generating model TSSSE and inference model BiSSE.__", echo = F}
hist(data[, 4], main = "", 
     breaks = 20, xlab = "p-value from LRT",
     col = c("red", rep("black", 19)))
text(.51, 8, paste(round(sum(data[1:86, 4]<=.05)/86*100), "% Significant", sep=""))
```

&nbsp;

&nbsp;

Finally we can look at how this works when we evolve a neutral trait on a tree that has variation in diversification.
```{r, fig.cap="__Assesment of type 1 error rate. Neutral trait and TSSSE inference model.__", echo = F}
hist(data[, 6], main = "", 
     breaks = 20, xlab = "p-value from LRT",
     col = c("red", rep("black", 19)))
text(.475, 8, paste(round(sum(data[1:67, 6]<=.05)/67*100), "% Significant", sep=""))
```

Next lets see what happens when the trait is neutral with no effect on diversification.
```{r, fig.cap="__Assesment of type 1 error rate. Neutral trait and BiSSE inference model.__", echo = F}
hist(data[, 5], main = "", 
     breaks = 20, xlab = "p-value from LRT",
     col = c("red", rep("black", 19)))
text(.51, 8, paste(round(sum(data[1:100, 5]<=.05)/100*100), "% Significant", sep=""))
```



