install.packages("knitr", lib="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
library("coda", lib.loc="~/Library/R/3.2/library")
library("heath")
help(barplot)
data("chickwts")
View(chickwts)
barplot(chickwts ~ feed, data= chickwts)
View(chickwts)
barplot(weight ~ feed, data= chickwts)
boxplot(weight ~ feed, data= chickwts)
.005^2
help("mode")
library("evobiR", lib.loc="~/Library/R/3.2/library")
Mode()
Mode
Mode <- function(x){
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
Mode(c(1,1,1,3))
Mode <- function(x){
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
Mode(c(1,1,1,3))
Mode <- function(x){
ux <- unique(x)
return(c("help", ux[which.max(tabulate(match(x, ux)))]))
}
Mode(c(1,1,1,3))
Mode <- function(x){
if(!is.vector(x)) stop("must supply a vector")
ux <- unique(x)
mode.x <- ux[which.max(tabulate(match(x, ux)))]
return(mode.x)
}
Mode(c(1,1,1,3))
Mode("heath")
Mode(matrix(1:9, 3, 3))
is.numeric(c(1,3,6))
sum.x <- vector(length = length(x))
x <- c(1,2,3,4)
sum.x <- vector(length = length(x))
sum.x <- vector(type="numeric", length = length(x))
help(vector)
x <- c(140.08, 87.62, 217.75, 144.96, 50.24, 44.85, 259.27, 29.74)
y <- c(17.6, 56.66, 141.64, 144.59, 489, 45.25, 65.81, 75.39)
help("t.test")
t.test(x=y,y=x,paired=F, alternative="greater")
boxplot(x,y)
load("~/Desktop/Dropbox/gitrepos/development/fragileY.sim/initial-results.rda")
totals
sqrt(121)
resolution <- 0.005 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
# x and y are set up and good to go
a <- interp(x=rep(seq.int(from=0,to=.1,length.out = 11), 11),
y=rep(seq.int(from=1,to=1.5,length.out = 11), each=11),
# this is the actual data it will need to read the csv from bottom
# left to upper right
z=totals,
xo=seq(0,.1,by=resolution/20),
yo=seq(1,1.5,by=resolution))
image(a, col=viridis::viridis(34), ylab="S.A. Ratio", xlab="Aneuploidy Rate",
main= "Probability of fixing inversion")
color.legend(xl=.1005,yb=1,xr=.1015,yt=1.5, gradient="y",align="rb",
legend=c("0%","10%","20%"),rect.col=viridis::viridis(20), cex=.7)
library(akima)
resolution <- 0.005 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
# x and y are set up and good to go
a <- interp(x=rep(seq.int(from=0,to=.1,length.out = 11), 11),
y=rep(seq.int(from=1,to=1.5,length.out = 11), each=11),
# this is the actual data it will need to read the csv from bottom
# left to upper right
z=totals,
xo=seq(0,.1,by=resolution/20),
yo=seq(1,1.5,by=resolution))
image(a, col=viridis::viridis(34), ylab="S.A. Ratio", xlab="Aneuploidy Rate",
main= "Probability of fixing inversion")
color.legend(xl=.1005,yb=1,xr=.1015,yt=1.5, gradient="y",align="rb",
legend=c("0%","10%","20%"),rect.col=viridis::viridis(20), cex=.7)
image(a, col=viridis::viridis(34), ylab="S.A. Ratio", xlab="Aneuploidy Rate",
main= "Probability of fixing Y \nchromosome inversion")
color.legend(xl=.1005,yb=1,xr=.1015,yt=1.5, gradient="y",align="rb",
legend=c("0%","10%","20%"),rect.col=viridis::viridis(20), cex=.7)
help(color.legend)
??color.legend
library(plotrix)
image(a, col=viridis::viridis(34), ylab="S.A. Ratio", xlab="Aneuploidy Rate",
main= "Probability of fixing Y \nchromosome inversion")
color.legend(xl=.1005,yb=1,xr=.1015,yt=1.5, gradient="y",align="rb",
legend=c("0%","10%","20%"),rect.col=viridis::viridis(20), cex=.7)
load("~/Desktop/Dropbox/gitrepos/r-packages/LCAdata/data/lca.data.rda")
lca.data[[82]]
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv")
hist(data[,1])
View(data)
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv", row.names = NULL)
View(data)
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv", row.names = 1:100)
hist(data[,1])
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv", row.names = 1:100)
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv", row.names=1)
hist(data[,1])
hist(data[,1])
hist(data[,2])
hist(data[,1],main="Power: generating TSSSE\ninference TSSSE")
hist(data[,1],main="Power\ngenerating TSSSE\ninference TSSSE")
data[, 1]<=.05
View(data)
sum(data[, 1]<=.05))
sum(data[, 1]<=.05)
sum(data[, 1]<=.05)/100
text(.5, 60, paste(sum(data[, 1]<=.05)/100*100, "% Significant")
)
text(.5, 60, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep="")
)
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE")
text(.5, 60, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep=""))
abline(h=.05)
help("hist")
1/.05
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE", breaks = 20)
text(.5, 60, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep=""))
abline(v=.05, col="red")
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE", breaks = 20,col="red")
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE", breaks = 20,col=c("red","black"))
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE", breaks = 20,col=c("red",rep("black", 19)))
text(.5, 60, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep=""))
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE",
breaks = 20, xlab = "p-value from LRT"
col = c("red", rep("black", 19)))
hist(data[, 1], main = "Power\ngenerating TSSSE\ninference TSSSE",
breaks = 20, xlab = "p-value from LRT",
col = c("red", rep("black", 19)))
text(.5, 60, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep=""))
text(.5, 40, paste(sum(data[, 1]<=.05)/100*100, "% Significant", sep=""))
So a note here the constrained version of the TSSSE model does give the find.mle function a bit of trouble.  The results that are presented below are from those datasets where the find.mle fucntion appeared to successfuly find a global optimum.
View(data)
View(data)
load("~/Desktop/tssse-results.RData")
View(final.results)
i<- 1
tss.W.res <- vector()
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
View(data.mat)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
library(diversitree)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 10*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 10*q12)
pars <- c(1, 1,    # lambda 2, 3
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 10*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 10*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
tss.W.res
tss.W.res<=.05
sum(tss.W.res<=.05)
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 5*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 5*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 30*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 30*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
citations()
citation()
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/labnotebook")
library(diversitree)
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 30*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 30*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
setwd("~/Desktop/TSSSE")
tree <- read.tree("whales.tre")
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/labnotebook")
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/labnotebook")
tree <- read.tree("whales.tre")
library(geiger)
tree <- rescale(tree, model="depth", depth=1)
q <- list(rbind(c(-.2, .2, .0),
c(.0, -.9, .9),
c(.0, .0, .0)))
foo <- sim.char(tree, q, model="discrete", n=400)[,1,]
# We simulated 400 datasets lets just pull out 100 that have a good mix of states
check <- vector()
for(i in 1:400){
check[i] <- sum(foo[,i]==1) < 70 & sum(foo[,i]==1) > 10
}
foo <- foo[,which(check)[1:100]]
# and we will rename something sensible
neut.data <- foo
for(i in 1:100){
neut.data[, i][neut.data[, i] == 3] <- 2
}
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 30*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 30*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
warnings()
tss.W.res[!is.na(tss.W.res)]
tss.W.res<=.05
sum(bis.W.res<-bis.W.res[!is.na(bis.W.res)])
sum(tss.W.res<=.05)
res.30 <- tss.W.res
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 10*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 10*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
res.10 <- tss.W.res
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 2*q12)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 2*q12)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 2)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 2)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
res.2 <- tss.W.res
hist(res.2, main = "",
breaks = 20, xlab = "p-value from LRT",
col = c("red", rep("black", 19)))
text(.51, 8, paste(round(sum(data[1:100, 5]<=.05)/100*100), "% Significant", sep=""))
write.csv(res.2, file="TSSE.result2.csv")
data2 <- read.csv("TSSE.result2.csv")
hist(data2, main = "",
breaks = 20, xlab = "p-value from LRT",
col = c("red", rep("black", 19)))
text(.51, 8, paste(round(sum(data2<=.05)/100*100), "% Significant", sep=""))
```{r, fig.cap="__Assesment of type 1 error rate. Neutral trait and TSSSE inference with fixed rate for transition out of temporary state model.__", echo = F}
data <- read.csv("http://coleoguy.github.io/labnotebook/TSSSE.results.csv", row.names = 1)
data2 <- read.csv("TSSE.result2.csv")
View(data2)
data2 <- read.csv("TSSE.result2.csv", row.names = 1)
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/labnotebook")
tree <- read.tree("whales.tre")
library(geiger)
tree <- rescale(tree, model="depth", depth=1)
q <- list(rbind(c(-.2, .2, .0),
c(.0, -.9, .9),
c(.0, .0, .0)))
foo <- sim.char(tree, q, model="discrete", n=400)[,1,]
# We simulated 400 datasets lets just pull out 100 that have a good mix of states
check <- vector()
for(i in 1:400){
check[i] <- sum(foo[,i]==1) < 70 & sum(foo[,i]==1) > 10
}
foo <- foo[,which(check)[1:100]]
# and we will rename something sensible
neut.data <- foo
for(i in 1:100){
neut.data[, i][neut.data[, i] == 3] <- 2
}
tree <- read.tree("whales.tre")
library(geiger)
tree <- rescale(tree, model="depth", depth=1)
q <- list(rbind(c(-.2, .2, .0),
c(.0, -.9, .9),
c(.0, .0, .0)))
foo <- sim.char(tree, q, model="discrete", n=400)[,1,]
# We simulated 400 datasets lets just pull out 100 that have a good mix of states
check <- vector()
for(i in 1:400){
check[i] <- sum(foo[,i]==1) < 70 & sum(foo[,i]==1) > 10
}
foo <- foo[,which(check)[1:100]]
# and we will rename something sensible
neut.data <- foo
for(i in 1:100){
neut.data[, i][neut.data[, i] == 3] <- 2
}
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 10)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 10)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
tss.W.res
View(neut.data)
tss.W.res <- vector()
for(i in 1:100){
print(i)
data.mat <- matrix(0,87,3)
data.mat[neut.data[,i] == 1, 1] <- 1
data.mat[neut.data[,i] == 2, 2] <- 1
data.mat[neut.data[,i] == 2, 3] <- 1
row.names(data.mat) <- row.names(neut.data)
MUSS.lik <- make.musse(tree, states=data.mat, strict=F, k=3)
TSS.lik <- constrain(MUSS.lik, lambda1 ~ lambda3, q13 ~ 0, q21 ~ 0,
q31 ~ 0, q32 ~ 0, q23 ~ 100)
TSS.likl <- constrain(MUSS.lik, lambda1 ~ lambda3, lambda2 ~ lambda3,
q13 ~ 0, q21 ~ 0, q31 ~ 0, q32 ~ 0, q23 ~ 100)
pars <- c(1, 1,    # lambda 2, 3
0.01, 0.01, 0.01,# mu 1, 2, 3
0.1)            # q12
#0.5)            # q23
print("fitting full model")
fit <- find.mle(TSS.lik, pars)
print("fitting constrained model")
fit.l <- find.mle(TSS.likl, pars[c(1,3:6)])
tss.W.res[i] <- anova(fit, equal.lambda=fit.l)[5]$`Pr(>|Chi|)`[2]
}
sum(tss.W.res<=.05)
res.2 <- tss.W.res
hist(res.2, main = "",
breaks = 20, xlab = "p-value from LRT",
col = c("red", rep("black", 19)))
x<- matrix(,4,4)
x2 <- as.data.frame(matrix(,4,4))
x<- matrix(1,4,4)
x2 <- as.data.frame(matrix(1,4,4))
View(x)
View(x2)
x[1,1] <- "heath"
x2[1,1] <- "heath"
View(x2)
View(x)
x[1,1]
x[2,2]
x2[1,1]
x2[2,2]
