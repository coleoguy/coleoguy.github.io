---
title: "Analyses for paper with Laura and Doris"
author: "Heath Blackmon"
date: "February 1, 2016"
output: html_document
---
We need to add a few analyses to this paper and since we first started a nice tree has become available: [Phylogenomics resolves the timing and pattern of insect evolution](http://science.sciencemag.org.ezp1.lib.umn.edu/content/346/6210/763.full.pdf+html?) this paper includes a consensus tree with node dates equal to the median of from their bayesian analysis.  This tree has 1-4 tips for each order.

```{r}
library(diversitree)
library(ape)
library(geiger)
tree <- read.nexus("insects.nex")
plot(tree, cex = .4)
```
```write.csv(tree$tip.label,file="names.csv")```

Outside of R I created a table that has the tree tip names in the first collumn.  The second column has each order name entered only one time (so mostly blanks). So the next step is to prune this tree so we have a single tip for each order.

```{r}
taxa <- read.csv("names.csv", as.is = T)

# create a vector with length the same as number of orders
nums <- rep(1, sum(taxa[, 2] != ""))

# provide the correct order names for the tips we will keep
names(nums) <- taxa[, 1][taxa[, 2] != ""]

# prune the tree to just those tips we are keeping
new.tree <- treedata(tree, nums, warnings=F)[[1]]

# trade out original tip names with order names
for(i in 1:length(new.tree$tip.label)){
  hit <- which(taxa[, 1] == new.tree$tip.label[i])
  new.tree$tip.label[i] <- taxa[hit, 2]
}

# now plot new tree
plot(new.tree, cex = .75)
# that looks good, lets clean up some
rm(filter, taxa, foo, hit, i, nums, tree)
```

Ok now that we have a dated consensus phylogeny we can do several analyses that I felt unsure of previously.  For the first one lets do the reconstruction of the sex chromosome system.  The first problem that we face in this case is that we have variation in some groups however, for most groups there is a clear consensus.  The approach that we will use is to simply take the probability of being in each tip state as being equal to the frequency of that state in an order.  For instance if 90% of records are XY and 10% of records are XO we would place a prior probability of 90% on the state XY and a 10% prior probability on the state XO.

The first thing that we will do is make the empty state matrix
```{r}
scs.states <- c("XY", "XO", "ZW", "ZO", "HD")
states <- matrix(,length(new.tree$tip.label), length(scs.states))
colnames(states) <- scs.states
row.names(states) <- new.tree$tip.label
rm(scs.states)
```

Now we will fill this in
```{r}
data <- read.csv("tos.data.csv", as.is = T)
for(i in 1:nrow(states)){
  temp.data <- data[tolower(data$Order) == row.names(states)[i], 6]
  states[i, 1] <- sum(temp.data == "XY" | temp.data == "complex XY|homomorphic" | 
                      temp.data == "complex XY" | temp.data == "XY|homomorphic")
  states[i, 2] <- sum(temp.data == "XO" | temp.data == "complex XO")
  states[i, 3] <- sum(temp.data == "ZW" | temp.data == "complex ZW")
  states[i, 4] <- sum(temp.data == "ZO")
  temp.data <- data[tolower(data$Order) == row.names(states)[i], 9]
  states[i, 5] <- sum(temp.data == "paternal genome elimination" | temp.data == "arrhenotoky")
}

knitr::kable(states)

```


One problem with our current dataset is the numbers in Hemiptera.  In our database this order is made up almost strictly of scale insects.  This heavily biases the distribution towards PGE/HD.  Other workers in this field report that XY and XO are both common with XY most common.  I've requested some papers and have others being delivered I should be able to supplement our current dataset with 200-300 new datapoints prior to publication.  Judging from the distribution of the first 100 it looks like the eventual distribution of systems in our dataset will be 
XY=228
XO=92
PGE/HD=247
```{r}
states[row.names(states) == "hemiptera", c(1, 2)] <- c(228,  92) 
```
I'll update these numbers as the data rolls in but this should get things started.

First step in the ancestral state reconstruction is changing these counts into proportions.  Three orders have no data so they will have equal probability of being in any state.
```{r}
for(i in 1:nrow(states)){
  if(sum(states[i, ]) == 0) states[i, ] <- c(1,1,1,1,1)
  states[i, ] <- states[i, ] / sum(states[i, ])
}
knitr::kable(states)
rm(i, temp.data, data)
```

```{r}
lik <- make.musse(new.tree, states, 5, strict=F)
argnames(lik)
con.lik <- constrain(lik, 
                     lambda5 ~ lambda1, lambda4 ~ lambda1, lambda3 ~ lambda1, lambda2 ~ lambda1,
                     mu5 ~ mu1, mu4 ~ mu1, mu3 ~ mu1, mu2 ~ mu1, 
          # transitions in SDSs should not start w/o a W/Y
                    q32 ~ 0, q42 ~ 0, q14 ~ 0, q24 ~ 0, 
          # transitions from all XY = 
                    q13 ~ q23, 
          # transitions from all ZW =
                    q31 ~ q41,
          # loss of Y or W single rate
                    q12 ~ q34,
          # single rate of Y or W gain
                    q21 ~ q43,
          # ZW and ZO single rate to HD
                    q35 ~ q45,
          # XY and XO single rate to HD
                    q15 ~ q25,
          # single rate of HD to XY or ZW
                    q51 ~ q54, q52 ~ q54, q53 ~ q54)
argnames(con.lik)
starting.p <- c(.001, .001, .001, .001, 10, .001, 10, .001, .001)
find.mle(con.lik, x.init=starting.p, root=ROOT.OBS)
find.mle(lik, x.init=rep(.01,30), root=ROOT.OBS)





new.states <- states[,c(1,3,5)]
new.states[,1] <- states[,1] + states[,2]
new.states[,2] <- states[,3] + states[,4]
new.states[,3] <- states[,5]
lik <- make.mkn(new.tree, new.states, 3, strict=F)
argnames(lik)
con.lik <- constrain(lik, q13 ~ q23, q31 ~ q32)
argnames(con.lik)
find.mle(con.lik, x.init=rep(.01,4), root=ROOT.OBS)






library(phytools)
foo <- make.simmap(tree = new.tree, x = states, model="ARD", pi=c(1,0,0,0,0), q="mcmc", nsims=100)
foo <- make.simmap(tree = new.tree, x = states, model="ARD", pi="estimated")
plotSimmap(foo)



```












