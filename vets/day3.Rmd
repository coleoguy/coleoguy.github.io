---
title: "Control structures and functions"
author: "Heath Blackmon"
date: "9/22/2017"
output:
  html_document:
    toc: yes
    toc_depth: 2
  pdf_document:
    toc: yes
    toc_depth: '2'
---

#Control Structures

Last week we looked at `for`, `while`, and `if`.  Today we will cover the apply family of functions.  These functions allow us to perform repeated tasks like we might with `for` but alleviate the need to right an explicit loop.  There are two main advantages to using `apply` over `for`.  First, your code can be much shorter and second in some though not all cases it can be faster.  Lets compare a for solution and an apply solution to the same problem:

```{r}
# First lets create some data lets do test scores:
test1 <- rnorm(8, mean = 70, sd = 10)
test2 <- rnorm(8, mean = 75, sd = 10)
test3 <- rnorm(8, mean = 85, sd = 10)
test4 <- rnorm(8, mean = 81, sd = 10)
data <- matrix(c(test1, test2, test3, test4), 8, 4)
row.names(data) <- c("richard", "kathy", "martha", "joseph", "kristina", "heath", "leslie", "abbigail")

# First we can use a for loop to look at everyones grade
grades1 <- vector()
for(i in 1:nrow(data)){
  grades1[i] <- mean(data[i, ])
}
grades1

# now we can see how to use an apply statement instead
grades2 <- apply(X=data, MARGIN = 1, FUN = mean)
grades2

# we can compare these with ==
grades1 == grades2
```

How do we save time with an apply vs a for loop.  The biggest savings is that apply builds in good computational practices like pre-allocation.  Lets look at an example of the time savings that comes with pre-allocation

```{r}
# first we make a big table to analyze
x <- rnorm(1000)
for(i in 1:100) x <- rbind(x, rnorm(1000))

# first without pre allocation
ptm <- proc.time()
result <- as.data.frame(matrix(, 1, 2))
for(i in 1:1000){
  result[i, 1] <- min(x[, i])
  result[i, 2] <- max(x[, i])
}
proc.time() - ptm

# with pre allocation
ptm <- proc.time()
result <- as.data.frame(matrix(, 1000, 2))
for(i in 1:1000){
  result[i, 1] <- min(x[, i])
  result[i, 2] <- max(x[, i])
}
proc.time() - ptm

# now with apply
ptm <- proc.time()
result <- cbind(apply(X = x, MARGIN = 2, FUN = min),
                apply(X = x, MARGIN = 2, FUN = max))
proc.time() - ptm
```

So why do we get such a big speed up by simply making our table the correct size?  Well it ends up that in the first case where the table is getting bigger with each itteration we are actually throwing away our old table and creating a new one with each loop.  

Here are the specifics on what we give teh `apply` function:
`X` is a matrix or dataframe
`MARGIN` defines how the function is applied: when `MARGIN=1`, it applies over rows, whereas with `MARGIN=2`, it applies over columns. 
`FUN` is the function that you want to apply to the data

The apply function is just one of a member of similar functions like `tapply`, `sapply`, `lapply`, `mapply`.  

<br>
<br>

#User defined functions

One of the secrets to writing good clean code is to use functions.  So what is a function?  A function is just a bit of code that takes in some arguments and provides an output.  For instance, we have been using the function `mean` which takes in a vector of numbers and returns the numeric mean.  We create a function using the `function` command.  Here is an example creating a function called `OurMean`.

```{r}
OurMean <- function(x){
  sum(x) / length(x)
}

# lets try using it
grades <- c(98.25, 0, 100, 87.5, 99)
OurMean(grades)

# we can compare ours to the standard function
mean(grades)
```

We can pass any number of arguments in our function for instance maybe we want to allow our students to drop their lowest grade.  If so we might right this mean function:
```{r}
OurMean <- function(x, drop = F){
  if(drop == F) {
    z <- sum(x) / length(x)
  }
  if(drop == T) {
    z <- (sum(x[-which.min(x)])) / (length(x) - 1)
  }
  return(z)
}

# lets try using it
grades <- c(98.25, 0, 100, 87.5, 99)
OurMean(x = grades, drop = F)
OurMean(x = grades, drop = T)
```

So when should we write a function in our code rather than just writing a script to perform our analysis?

1) if we have several lines of code that we use repeatedly we should create a function: Often problems in code come from typos writing your code one time reduces this chance.

2) if our code is more than 100 lines: Very long scripts can be hard to interpret later.  By breaking your code into functions and giving them names that describe what they do you make you code easier to understand and work with.

<br>
<br>

# Validation in functions
Validation is the practice of including checks in your code that insure that the input data is what you think it is.  This is especially important when you begin bigger projects or if you want to use your code in the future.  For instance we performed no validation in the function we wrote OurMean.  What would happen if you gave it a logical vector instead of a numeric vector?

```{r}
lv <- c(T, F, T, T, F, F, F)
OurMean(lv)
````

We see here that our function just treated the TRUE and FALSE values as 1 and 0.  What if we gave it a character vector, a matrix?

```{r, eval=FALSE}
cv <- c("abe", "bob", "abe")
OurMean(cv)
nm <- matrix(c(98,87,23,99),2,2)
OurMean(nm)
```

Lets rewrite our function with some validation steps added:
```{r}
OurMean <- function(x, drop = F){
  if(class(x) != "numeric"){
    zfail <- paste("x is expected to be class numeric but was class", class(x), "instead")
    stop(zfail)
  }
  if(drop == F) {
    z <- sum(x) / length(x)
  }
  if(drop == T) {
    z <- (sum(x[-which.min(x)])) / (length(x) - 1)
  }
  return(z)
}

```

<br>
<br>

#Challenges

<br>
<br>

##Challenge 1
Write a function that converts fahrenheit to celsius.  Rember that C = (F-32) * 5/9. Try to make it so it can work on a vector of temperatures rather than just a single value. 

Input will look like this:
`f.temps <- c(87,98,32)`

The output should be a vector of the same length but with the converted temperatures

<br>
<br>

##Challenge 2
Write a function that will make a table.

The input will be a list of values
`letters <- sample(letters, 100, replace=T)`

The output should look like this (only first two lines shown)


letter | count
-------|--------
a      |4
b      |1













