}else{
y[i] <- y[(i-1)]
}
if(runif(min=0, max=1, n=1)>.99){
z[i] <- z[(i-1)] + sample(c(-1,1,z[(i-1)]),prob=c(.45,.4,.01),size=1)
}else{
z[i] <- z[(i-1)]
}
}
}
plot(x,type="l", col=rgb(.05,.33,.31),lwd=2,ylim=c(8,20),xlab="time",ylab="chromosome number")
lines(y, col=rgb(.5,.27,.11),lwd=2)
lines(z, col=rgb(.82,.66,.32),lwd=2)
plot(x,type="l", col=rgb(.05,.33,.31),lwd=2,ylim=c(6,17),xlab="time",ylab="chromosome number")
lines(y, col=rgb(.5,.27,.11),lwd=2)
lines(z, col=rgb(.82,.66,.32),lwd=2)
x <- c(0,.25,.5,.5,.5,.75,1)
x <- c(0,.25,.5,.5,.5,.75,1)
y <- c(10,13,14.5,1.7,15,17.5,18)
plot(x,y)
x <- c(0,.25,.5,.5,.5,.75,1)
y <- c(10,13,14.5,14.7,15,17.5,18)
plot(x,y)
x <- c(0,.25,.5,.5,.5,.75,1)
y <- c(10,13,15.5,15.7,15,17.5,18)
plot(x,y)
x <- c(0,.25,.5,.5,.5,.75,1)
y <- c(10,13,12.5,15.7,15,17.5,18)
plot(x,y)
plot(x,y, cex=16)
plot(x,y, cex=1.5,pch=16)
plot(x,y, cex=1.5,pch=16, col="blue")
plot(x,y, cex=1.5,pch=16, col="darkgreen")
line(x=c(0,1),y=c(10,18))
lines(x=c(0,1),y=c(10,18))
lines(x=c(0,1),y=c(10,18),lwd=2,lty=3)
plot(x,y, cex=1.5,pch=16, col="darkgreen")
lines(x=c(0,1),y=c(10,18),lwd=2,lty=3)
points(x,y, cex=1.5,pch=16, col="darkgreen")
plot(x,y, cex=1.5,pch=16, col="darkgreen",ylim=c(9,19),xlim=c(-.1,1.1))
lines(x=c(0,1),y=c(10,18),lwd=2,lty=3)
points(x,y, cex=1.5,pch=16, col="darkgreen")
load("~/Desktop/SSE2.RData")
for(i in 85:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
UnitScale <- function(x){
z <- max(branching.times(x))
x$edge.length <- x$edge.length/z
return(x)
}
GetOverlap <- function(x, burnin){
library(coda)
topnum <- nrow(x) - burnin
z <- vector()
for(i in 1:topnum){
j <- i + burnin
z[i] <- ((x[j, 2] + x[j, 3]) / 2) -
((x[j, 4] + x[j, 5]) / 2)
}
z <- HPDinterval(as.mcmc(z), prob=0.95)
return(z)
}
library(chromePlus)
library(diversitree)
for(i in 85:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 85:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 88:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 93:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 95:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 99:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 99:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
for(i in 99:100){ # 2 try(s) fixed for a bianry state
print(paste("working on simulation", i))
data <- makeSSEchrom(h=20,
lambda1=6, lambda2=3,
mu1=1, mu2=1,
asc1=3, asc2=1,
desc1=3, desc2=1,
trans1=1, trans2=1,
max.taxa=200, x0=10)
cdat <- data.frame(data$tree$tip.label,
as.numeric(data$haploid.num),
as.numeric(data$binary.char))
colnames(cdat) <- c("taxa", "haploid", "bin")
z <- range(cdat[,2])
z[1] <- z[1] - 1
z[2] <- z[2] + 1
cmat <- datatoMatrix(cdat, range=z, hyper=T)
lk.mk <- make.musse(data$tree, states=cmat, k=ncol(cmat),
strict=F, control=list(method="ode"))
wo.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = T, s.mu = T,
constrain=list(drop.demi=T, drop.poly=T))
w.sse <-constrainMuSSE(data=cmat,
lik=lk.mk,
hidden=T, polyploidy=F,
verbose=F,
s.lambda = F, s.mu = F,
constrain=list(drop.demi=T, drop.poly=T))
x.w[[i]] <- diversitree::mcmc(w.sse, print.every = 25,
lower=rep(0,10),
upper=rep(20,10),
x.init=runif(min=0,max=5, 10),
w=1, nsteps=1000)
x.wo[[i]] <- diversitree::mcmc(wo.sse, print.every = 25,
lower=rep(0,8),
upper=rep(20,8),
x.init=runif(min=0,max=5, 8),
w=1, nsteps=1000)
}
save.image("~/Desktop/SSE2.RData")
2+2
x <- 45
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/vets")
getwd()
hist(rnorm(100))
y <- c("ann", "john", "heath")
x <- "bob"
y <- c("ann", "john", "heath")
z <- c("ann", "john", "bob")
x %in% y
x %in% z
x <- c("bob", "john")
y <- c("ann", "john", "heath")
z <- c("ann", "john", "bob")
x %in% y
my.list <- list(x,y,z)
my.list[[3]]
my.list[[3]][2]
iris.sizes <- read.csv("iris.csv")
plot(iris.sizes)
x <- iris.sizes$Petal.Length
y <- iris.sizes$Petal.Width
plot(y ~ x)
lm(y~x)
mod1 <- lm(y~x)
summary(mod1)
abline(mod1)
abline(v=2.5, col="red")
plot(y ~ x, xlab = "Petal length",
ylab = "Petal width")
plot(y ~ x, xlab = "Petal length",
ylab = "Petal width", pch=16)
plot(y ~ x, xlab = "Petal length",
ylab = "Petal width", pch=16,
col="maroon")
plot(y ~ x, xlab = "Petal length",
ylab = "Petal width", pch=16,
col="maroon", main="Test")
plot(y ~ x, xlab = "Petal length",
ylab = "Petal width", pch=16,
col="maroon", main="Irises")
abline(mod1)
plot(y ~ x, xlab = "Petal length",
ylab = "Petal width", pch=16,
col="maroon", main="Irises")
abline(mod1, lty=2)
abline(v=2.5, col="red", lwd=3)
unique(iris.sizes$Species)
wanted.rows <- iris.sizes$Species=="setosa"
wanted.rows
iris.sizes$Petal.Length[wanted.rows]
small.iris <- iris.sizes$Petal.Length[wanted.rows]
wanted.rows <- iris.sizes$Species=="virginica"
large.iris <- iris.sizes$Petal.Length[wanted.rows]
large.iris
plot(density(small.iris), xlim=c(0,7))
lines(density(large.iris),col="blue")
plot(density(small.iris), xlim=c(0,8))
lines(density(large.iris),col="blue")
my.df <-    data.frame(
gender = c("Female","Female", "Male","Female","Female",
"Male","Female", "Male","Female", "Male",
"Male","Female","Female"),
score = c(99, 93, 92, 93, 89,
54, 89, 95, 95, 88,
87, 97, 91))
my.df
plot(my.df$gender)
plot(my.df$score)
class(my.df$gender)
class(my.df$score)
