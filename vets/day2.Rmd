---
title: "Logical Operators and Control Structures"
author: "Heath Blackmon"
date: "9/22/2017"
output: html_document
---

An algorithm is defined as: **a process or set of rules to be followed in calculations or other problem-solving operations**



Todays we are going to spend quite a bit of time learning how to use control structures and logical operators.  These two aspect of computer languages allow us to build complex algorithms that are central to much of data science.  These are improtant tools regardless of the programming language you use or field of study that you go into. Because of this, much of what we learn here will apply when we work with Python as well.

#Logical operators?
Logical operators are simply operators that evaluate two arguments and return either `TRUE` or `FALSE`.  R has many of these:

Operator| Description
--------|----------------------------------
`>`        |checks if each element of the first vector is larger than the corresponding element of the second
`<`        |checks if each element of the first vector is less than the corresponding element of the second
`==`       |checks if each element of the first vector is equal to the corresponding element of the second
`<=`       |checks if each element of the first vector is smaller than or equal to the corresponding element of the second
`>=`       |checks if each element of the first vector is larger than or equal to the corresponding element of the second
`!=`       |checks if each element of the first vector is not equal to the corresponding element of the second
`&`        |combine corresponding values of two vector, if both are TRUE returns TRUE otherwise returns false
`|`        |combine corresponding values of two vector, if either are TRUE returns TRUE otherwise returns false
`!`        |negates the logical values in the vector
`%in%`     |checks to see if the item  to the left is an element in the item to the right.


So lets look at some examples of how we might use these.


```{r}
4 < 3
4 <= 3
"Abe" == "abe"
"EILSEL" == "EILSEL"

x <- c(1, 2, 4, 8, 23)
5 == x
4 == x
x == 4

z <- 4 == c(1, 4, 1, 4)
z
!z

3 == 3 & 3 == 3
2 == 3 & 2 < 3
2 == 3 | 2 < 3

"apple" %in% c("samsung", "apple", "alphabet", "htc")

c(1, 2, 4) == c(1, 2, 3)
c(1, 4) == c(1, 2, 3)
c(1, 4) == c(1, 2, 2, 4)
```


#Control structures?

Control structures allow you to control the way that the computer code you have written is executed.  R has a variety of control structures, but we will focus on only the most common of these today:

Control structure      | Description
-----------------------|----------------------------------
if(cond) expr          |When the provided condition is TRUE then it executes the block of code that follows it.
ifelse(test, yes, no)  |When test is TRUE executes code in yes block when test is FALSE executes code in no block
while(cond) expr       |Executes the block of code that follows it as long as the provided condition remains TRUE.
for(var in seq) expr   |executes a block of code repeatedly with var taking on each value present in seq

Lets look at some examples of these:

```{r}
# first if
if(4 == 4) {
  print("R is fun!")
}

if(4 == 3) {
  print("R is fun!")
}

# now ifelse
ifelse(4 == 4,"The statement is true", "The statement is false")
ifelse(4 > 4,"The statement is true", "The statement is false")
      
# here is an example of while
flag <- 1
while(flag < 4) {
  cat("I have done this", flag, "times already.\n")
  flag <- flag + 1
}

# for is another commonly used control structure
for(i in 1:3) {
  cat("the variable i has the value", i, "right now.\n")
}

# we can you for in another way too
names <- c("Vincent", "Jules", "Marsellus", "Zed")
for(i in names) {
  cat(i, "is a character in the movie Pulp Fiction\n")
}
```


# Challenges

For the rest of the day we will try some challenges.  The goal of these challenges is to use what we have learned to write simulations in R to answer questions.  Below are a list of all of the commands we might use:

Command                   | Description
--------------------------|--------------------------------
`length(x)`               | rerturns the length of x
`sample(x, replace, size)`| produces a sample of x of a specified size with or without replacement
`unique(x)`               | returns unique values of x
`mean(x)`                 | returns the arithmetic mean of x
`rep(x, times)`           | repeats x times
`if(cond) exp`            | if cond is true executes the expression following
`for(i in x) exp`         | executes the expression following while itterating through values of x 
`while(cond) exp`         | executes expression till condition is false
`vector()`                | creates a vector


## Challenge 1

What is the expected number of distinct birthdays in a group of 400 people? Assume 365 days and that all are equally likely.

Here is the solution we came up with as a group:
```{r}
result <- vector()
for(i in 1:100000){
  births <- sample(1:365, replace=T, size=400)
  birthdays <- unique(births)
  result[i] <- length(birthdays)
}

# Now lets see what we have discovered
paste("On average we expect to see", round(mean(result)), "unique birthdays in a room of 400 people.")
plot(density(result),xlab="Unique birthdays", main="Birthdays in a room of 400")
```

Here is a slightly shorter version that I came up with prior to class. The real difference in these is just that in this one I combined the `length`, `unique`, and `sample` commands onto a single line.

```{r}

bdays <- vector()
for(i in 1:1000) {
  bdays[i] <- length(unique(sample(1:365, replace = T, size=400))) 
}

# Now lets see what we have discovered
paste("On average we expect to see",  round(mean(bdays)), "unique birthdays in a room of 400 people")
```

## Challenge 2

If you were to randomly find a playing card on the floor every day, how many days would it take on average to find a full standard deck?y

Here is the solution that we came up with as a group:


```{r}
results <- vector()
for(i in 1:1000){
  days <- 0
  found <- vector()
  good <- F
  while(!good){
    days <- days + 1
    found <- c(found, sample(1:54, size=1))
    found <- unique(found)
    if(length(found) == 54){
      good <- T
    }
  }
  results[i] <- days
}

# Now lets see what we have discovered
hist(results, xlab="days")
```

Here is an alternative approach. In this case I first setup a vector of length 54 (we are obviously assuming that jokers are important) containing all `FALSE` values.  Then as we draw cards everytime we get one we switch the appropriate elements to `TRUE`.  Once all the elements are set to `TRUE` then we have reached our stopping point.

```{r}
deck <- 1:54
how.long <- vector()

for(i in 1:1000) {
  have <- rep(FALSE, 54)
  days <- 1
  while(sum(have) < 54) {
    pickup <- sample(1:54, size = 1)
    have[pickup] <- TRUE
    days <- days + 1
  }
  how.long[i] <- days
}

# Now lets see what we have discovered
hist(how.long, xlab="days")
```


## Challenge 3

If you take cards numbered from 1-10 and shuffle them, and lay them down in order, what is the probability that at least one card matches its position. For example card 3 comes down third?

This is the challenge that we ran out of time to do in class but here is an example of a solution:



```{r}

yes <- 0
for(i in 1:1000) {
  deal <- sample(1:10, replace=F, size=10)
  if(sum(1:10 == deal) > 0) {
    yes <- yes + 1
  }
}

# Now lets see what we have discovered
paste("There is a", yes/10, "% chance that at least one card matches it position")
```







