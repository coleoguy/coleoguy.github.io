qmat = qmat,
iter = 5000,
rate.classes = 9,
step = .2)
for(i in 1:100){
trees[[i]] <- trees(pars=c(3,1),
type="bd",
max.taxa = (i+99))[[1]]
depth <- max(branching.times(trees[[i]]))
trees[[i]]$edge.length <- trees[[i]]$edge.length / depth
traits[[i]] <- sim.character(tree = trees[[i]],
pars = qmat,
model = "mkn",x0 = 2)
}
library(castor)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 5000,
rate.classes = 9,
step = .2)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 9,
step = .2)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .2)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .2)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .2)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .2)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .8)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .99)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
bot <- 1/(1 + steps * step)
top <- 1 + steps * step
rates <- seq(from = bot,
to = top,
length.out = rate.classes)
rates
floor(rate.classes/2)
rate.classes
c(seq(from = bot,
to = 1,
length.out = steps+1),
seq(from = 1,
to = top,
length.out = steps+1)[-1]
)
rate.classes<-11
# set rate classes
steps <- floor(rate.classes/2)
bot <- 1/(1 + steps * step)
top <- 1 + steps * step
rates <- c(seq(from = bot,
to = 1,
length.out = steps+1),
seq(from = 1,
to = top,
length.out = steps+1)[-1]
# add our new element to the tree
tree$rates <- rep(ceiling(rate.classes/2),
Nedge(tree))
# we will store the likelihood trace here
lk.trace <- c()
# get the starting likelihood
lk1 <- asr_mk_model(tree = tree, tip_states = tip_states,
transition_matrix = qmat,
Nstates = ncol(qmat))$loglikelihood
# this will be the primary loop
for(j in 1:iter){
if(verbose == T){
if(j %% 500 == 0){
cat(j, "\n")
}
}
# this function tests a new rate only returns
# a result if it is better
result <- testNewRate(tree = tree, tip_states = tip_states,
transition_matrix = qmat,
Nstates = ncol(qmat),
rate.classes = rate.classes,
rates = rates, lk1 = lk1)
if(length(result) > 0){
tree <- result[[1]]
lk1 <- result[[2]]
}
lk.trace[j] <- lk1
}
# here we prepare the results
results <- list()
class(tree) <- "rateTree"
results[[1]] <- tree
results[[2]] <- lk.trace
results[[3]] <- rate.classes
names(results) <- c("tree","lk.trace", "num.rates")
return(results)
}
testNewRate <- function(tree = NULL, tip_states = NULL,
transition_matrix = NULL, Nstates = NULL,
rate.classes = NULL, rates = NULL, lk1 = NULL){
# create a temp tree
temp.tree <- tree
# sample an edge at random
edge <- sample(1:Nedge(tree), 1)
# evaluate and draw the possible rates we could
# assign to the sampled branch
poss.rate <- getRates(tree = tree,
edge = edge,
rate.classes = rate.classes)
# only bother doing something if it a change
if(poss.rate != tree$rates[edge]){
# apply the new rate
temp.tree$rates[edge] <- poss.rate
# change the branch lengths of all
# branches based on their rates
temp.tree$edge.length <- temp.tree$edge.length * rates[temp.tree$rates]
# calculate the likelihood of the scaled tree
lk2 <- asr_mk_model(tree = temp.tree,
tip_states = tip_states,
transition_matrix = transition_matrix,
Nstates = Nstates)$loglikelihood
# see if the new rate is better
if(lk2 > lk1){
tree$rates <- temp.tree$rates
lk1 <- lk2
return(list(tree, lk1))
}
}else{
return()
}
}
# this function returns possible
# rates for a sampled branch
getRates <- function(tree = NULL, edge = NULL, rate.classes = NULL){
# this gets the local rates
local.rates <- getLocalRates(tree, edge, rate.classes)
# this gets the intersection of possible rates and
# returns the numeric that describes the rate class
poss.rates <- getPossiRates(local.rates, rate.classes)
return(poss.rates)
}
getLocalRates <- function(tree = NULL, edge = NULL, rate.classes){
# get parent edge
p.edge <- which(tree$edge[, 2] == tree$edge[edge, 1])
# get daughter edge(s)
d.edges <- which(tree$edge[, 1] == tree$edge[edge, 2])
# if the branch has no parent we set it to the ML rate
if(length(p.edge) == 0){
rates <- median(1:rate.classes)
}else{
# get the rate of the parent edge
rates <- tree$rates[p.edge]
}
# check to see if the branch has daughters
if(length(d.edges) != 0){
# collect the daugter rates
rates <- c(rates, tree$rates[d.edges])
}
return(unique(rates))
}
getPossiRates <- function(local.rates = NULL, rate.classes = NULL){
x <- c(-1, 0, 1)
rate.mat <- as.data.frame(matrix(NA, 0, rate.classes))
for(i in 1:length(local.rates)){
z <- local.rates[i] + x
z <- z[z > 0 & z <= rate.classes]
rate.mat[i, z] <- 1
}
poss.rates <- as.numeric(which(colSums(rate.mat) == nrow(rate.mat)))
if(length(poss.rates) > 1){
poss.rates <- sample(poss.rates, 1)
}
return(poss.rates)
}
plotRateTree <- function(tree, rates,
scaled = F,
cols = NULL, bg = "white",
edge.width){
if(scaled){
tree$edge.length <- tree$edge.length * tree$rates
}
class(tree) <- "phylo"
if(is.null(cols)){
cols <- heat.colors(rates)[rates:1]
cols[median(1:rates)] <- "darkgray"
}
if(bg != "white"){
par(bg=bg)
}
plot(tree,
show.tip.label = F,
edge.color = cols[as.factor(tree$rates)],
edge.width = edge.width)
}
rates <- c(seq(from = bot,
to = 1,
length.out = steps+1),
seq(from = 1,
to = top,
length.out = steps+1)[-1])
rates
step = .2
# set rate classes
steps <- floor(rate.classes/2)
bot <- 1/(1 + steps * step)
top <- 1 + steps * step
rate.classes
# set rate classes
steps <- floor(rate.classes/2)
bot <- 1/(1 + steps * step)
top <- 1 + steps * step
rates <- c(seq(from = bot,
to = 1,
length.out = steps+1),
seq(from = 1,
to = top,
length.out = steps+1)[-1])
step = .5
step = .5
# set rate classes
steps <- floor(rate.classes/2)
bot <- 1/(1 + steps * step)
top <- 1 + steps * step
rates <- c(seq(from = bot,
to = 1,
length.out = steps+1),
seq(from = 1,
to = top,
length.out = steps+1)[-1])
rates
10*.28
10*3.5
source('~/Desktop/Dropbox/gitrepos/TreePainter/R/functions.R')
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = .99)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 3,
step = 10)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 9,
step = 9)
plotRateTree(tree = fit[[1]],
rates = 3,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 7000,
rate.classes = 9,
step = 9)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 12000,
rate.classes = 9,
step = 9)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
fit <- treePaintR(tree = trees[[100]],
tip_states = traits[[100]],
qmat = qmat,
iter = 12000,
rate.classes = 9,
step = 9)
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
source('~/Desktop/Dropbox/gitrepos/TreePainter/R/functions.R')
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
par(bg)
par()
source('~/Desktop/Dropbox/gitrepos/TreePainter/R/functions.R')
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
source('~/Desktop/Dropbox/gitrepos/TreePainter/R/functions.R')
plotRateTree(tree = fit[[1]],
rates = 9,
scaled = F,
cols=NULL,
bg="lightgray", edge.width = 1)
plot(fit$lk.trace, type = "l",
ylab = "lnLik",
xlab = "generation")
groups <- as.factor(sample(c("A","B"), 100, replace = T))
groups
as.numeric(groups)
group.effect <- groups
group.effect[group.effect==2] <- 3
group.effect <- as.numeric(groups)
group.effect[group.effect==2] <- 3
group.effect[group.effect==1] <- 0
group.effect
tl <- rnorm(100, mean=3, sd=.5) + rnorm(100, mean= group.effect, sd=.5)
boxplot(tl~groups)
tl <- rnorm(100, mean=2, sd=.5) + rnorm(100, mean= group.effect, sd=.5)
boxplot(tl~groups)
fit <- anova(lm(tl~groups))
summary(fit)
fit
fit <- lm(tl~groups)
summary(fit)
group.effect <- as.numeric(groups)
group.effect[group.effect==2] <- .5
group.effect[group.effect==1] <- 0
tl <- rnorm(100, mean=2, sd=.5) + rnorm(100, mean= group.effect, sd=.5)
boxplot(tl~groups)
anova(lm(tl~groups))
tl <- rnorm(100, mean=2, sd=.8) + rnorm(100, mean= group.effect, sd=.8)
boxplot(tl~groups)
anova(lm(tl~groups))
fit <- lm(tl~groups)
summary(fit)
groups <- as.factor(sample(c("A","B"), 100, replace = T))
group.effect <- as.numeric(groups)
group.effect[group.effect==2] <- 3
group.effect[group.effect==1] <- 0
temp <- runif(100, -5, 5)
groups <- as.factor(sample(c("A","B"), 100, replace = T))
group.effect <- as.numeric(groups)
group.effect[group.effect==2] <- 3
group.effect[group.effect==1] <- 0
temp <- runif(100, -5, 5)
tl <- rnorm(100, mean=2, sd = .8) +
rnorm(100, mean=temp, sd = 1) +
rnorm(100, mean= group.effect, sd=.8)
plot(tl ~ temp)
groups
as.numeric(groups)
c("blue", "red")[1]
c("blue", "red")[2]
c("blue", "red")[c(1,1,1,2)]
plot(tl ~ temp, col= c("blue", "red")[as.numeric(groups)], pch=16)
fit <- lme(tl ~ temp, random = ~1|groups)
library(nlme)
fit <- lme(tl ~ temp, random = ~1|groups)
summary(fit)
fit <- glm(tl ~ temp)
summary(fit)
fit <- glm(tl ~ temp + groups)
summary(fit)
rnorm(100, mean= group.effect, sd=.8)
hist(rnorm(100, mean= group.effect, sd=.8))
log(.000000000000000000000000001)
log(.000000000000000000000000000000000000000000000000000000000000000001)
log(.00000000000000000000000000000000000000001)
log(.00000001)
log(.001)
log(.1)
log(1)
log(5)
14768/2
# read in the data
dat <- read.csv("retrogene.csv", row.names = 1)
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/teaching/expdes/scripts")
# read in the data
dat <- read.csv("retrogene.csv", row.names = 1)
View(dat)
.3*12
74/12
.5/2
.25/2
.126/2
