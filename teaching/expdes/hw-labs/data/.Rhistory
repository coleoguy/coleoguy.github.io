summary(fit1)
summary(fit2)
summary(fit3)
anova(fit1,fit2)
anova(fit1,fit2,fit3)
fit4 <- lm(dat.m$mating.attempts ~ dat.m$body * dat.m$horns.resid)
anova(fit2,fit4)
summary(fit4)
getwd()
x <- rnorm(mean=.0234,sd=.008, n=1000)
plot(density(x))
x <- rnorm(mean=.0234,sd=.008, n=100)
plot(density(x))
x <- rnorm(mean=.0234,sd=.01, n=50)
plot(density(x))
x <- rnorm(mean=.0234,sd=.008, n=100)
y <- rnorm(mean=.0234,sd=.01, n=100)
plot(density(x))
plot(density(y))
x <- rnorm(mean=.0234,sd=.008, n=100)
y <- rnorm(mean=.0234,sd=.01, n=100)
plot(density(x))
plot(density(y))
x <- rnorm(mean=.0234,sd=.008, n=100)
x[x<0] <- 0
y <- rnorm(mean=.0234,sd=.02, n=100)
y[y<0] <- 0
plot(density(x))
plot(density(y))
x <- rnorm(mean=.0234,sd=.004, n=100)
x[x<0] <- 0
y <- rnorm(mean=.0234,sd=.02, n=100)
y[y<0] <- 0
plot(density(x), parameter estimate)
plot(density(x))
plot(density(y))
setwd("~/Desktop/Dropbox/projects/SAGA2/manuscript-unrecog-env/r.scripts/analysis")
ban <- read.csv("../../data/enviro.var/ban.osa.comb.csv", as.is=T)
bho <- read.csv("../../data/enviro.var/bho.sq.comb.csv", as.is=T)
ban.res <- LCA(data=ban, env=T)
library(SAGA2)
ban <- read.csv("../../data/enviro.var/ban.osa.comb.csv", as.is=T)
bho <- read.csv("../../data/enviro.var/bho.sq.comb.csv", as.is=T)
ban.res <- LCA(data=ban, env=T)
plot(ban.res, min.vi = .5)
plot(ban.res, min.vi = .1)
bho <- read.csv("../../data/enviro.var/bho.sq.comb.csv", as.is=T)
bho.res <- LCA(data=bho, env=T)
plot(bho.res, min.vi = .5)
help("LCA")
ban.res <- LCA(data=ban, env=T, model.sum = .9)
plot(ban.res, min.vi = .1)
bho.res <- LCA(data=bho, env=T, model.sum = .9)
plot(bho.res, min.vi = .5)
ba.all  <- read.csv("../../data/enviro.var/ba.sq.comb.csv", as.is=T)
ba.26  <- read.csv("../../data/ba.sq.26.csv", as.is=T)
View(ba.26)
View(ba.all)
ba.all  <- read.csv("../../data/enviro.var/ba.sq.comb.csv", as.is=T)
ba.26  <- read.csv("../../data/ba.sq.26.csv", as.is=T)
ba.all.res <- LCA(data=ba.all, env=T)
ba.26  <- read.csv("../../data/ba.sq.26.csv", as.is=T)
ba.26.res <- LCA(data=ba.26, env=T)
plot(ba.26.res, min.vi = .1)
plot(ba.all.res, min.vi = .1)
plot(ba.26.res, min.vi = .75)
plot(ba.all.res, min.vi = .75)
names(ba.26.res)
ba.26.res[[4]]
ba.all.res[[4]]
foo <- cbind(ba.26.res[[4]], ba.all.res[[4]])
View(foo)
foo <- cbind(t(ba.26.res[[4]]), t(ba.all.res[[4]]))
foo <- rbind(ba.26.res[[4]]), ba.all.res[[4]]))
foo <- rbind(ba.26.res[[4]], ba.all.res[[4]])
foo <- ba.26.res[[4]]
foo2 <- ba.all.res[[4]])
foo2 <- ba.all.res[[4]]
View(foo)
View(foo2)
load("~/Desktop/Dropbox/projects/SAGA2/manuscript-unrecog-env/results/env.neg.RData")
names(env.levels.neg)
foo <- env.levels.neg[[1]]
names(foo)
foo2 <- foo[[1]]
names(foo2)
foo3 <- foo2[[1]]
View(foo3)
dat1 <- read.csv("ba.sq.26.csv", as.is=T)
setwd("~/Desktop/Dropbox/projects/SAGA2/manuscript-unrecog-env/data")
dat1 <- read.csv("ba.sq.26.csv", as.is=T)
data <- dat1
SCS = "XY"
parental = "calc"
env = FALSE
model.sum = .95
max.models = 300000
drop.pars = NULL
max.pars = NULL
Cmatrix = NULL
ret.all = FALSE
messages = TRUE
if(is.factor(data$cross)){
data$cross <- unlist(lapply(data$cross, as.character))
}
if(is.logical(data$sex)){
data$sex <- rep("F", length(data$sex))
}
validateData(SCS = SCS, user.data = data, Cmatrix = Cmatrix, messages = messages)
if(is.null(Cmatrix)){
Cmatrix <- PrepareCmatrix(user.data = data,
SCS = SCS, env = env,
drop.pars = drop.pars,
parental = parental)
}
cmat.temp <- CleanCmatrix(Cmatrix)
Cmatrix <- cmat.temp[[1]]
crosses <- cmat.temp[[2]]
have.data <- paste(colnames(Cmatrix)[-1], collapse = ", ")
if(messages == T) cat(paste("The composite genetic effects that will be tested are: \n",
have.data, "\n", collapse = ", "))
dat1 <- read.csv("ba.sq.26.csv", as.is=T)
data <- dat1
SCS = "XY"
parental = "calc"
env = FALSE
model.sum = .95
max.models = 300000
drop.pars = NULL
max.pars = NULL
Cmatrix = NULL
ret.all = FALSE
messages = TRUE
if(is.factor(data$cross)){
data$cross <- unlist(lapply(data$cross, as.character))
}
if(is.logical(data$sex)){
data$sex <- rep("F", length(data$sex))
}
validateData(SCS = SCS, user.data = data, Cmatrix = Cmatrix, messages = messages)
source('~/Desktop/Dropbox/gitrepos/r-packages/SAGA2/R/support.R')
validateData(SCS = SCS, user.data = data, Cmatrix = Cmatrix, messages = messages)
if(is.null(Cmatrix)){
Cmatrix <- PrepareCmatrix(user.data = data,
SCS = SCS, env = env,
drop.pars = drop.pars,
parental = parental)
}
source('~/Desktop/Dropbox/gitrepos/r-packages/SAGA2/R/PrepareCmatrix.R')
validateData(SCS = SCS, user.data = data, Cmatrix = Cmatrix, messages = messages)
if(is.null(Cmatrix)){
Cmatrix <- PrepareCmatrix(user.data = data,
SCS = SCS, env = env,
drop.pars = drop.pars,
parental = parental)
}
library(gtools)
if(is.null(Cmatrix)){
Cmatrix <- PrepareCmatrix(user.data = data,
SCS = SCS, env = env,
drop.pars = drop.pars,
parental = parental)
}
cmat.temp <- CleanCmatrix(Cmatrix)
Cmatrix <- cmat.temp[[1]]
crosses <- cmat.temp[[2]]
have.data <- paste(colnames(Cmatrix)[-1], collapse = ", ")
if(messages == T) cat(paste("The composite genetic effects that will be tested are: \n",
have.data, "\n", collapse = ", "))
mod.space.size <- sum(choose(ncol(Cmatrix) -1 , 1:(nrow(Cmatrix) - 2)))
if(!is.null(max.pars)) mod.space.size <- sum(choose((ncol(Cmatrix) -1), 1:max.pars))
if(messages == T){
if(mod.space.size > 5000){
cat(paste("Since there are", mod.space.size,
"possible models this may take a bit:\n"))
}
}
pos.cols <- 2:ncol(Cmatrix)
eqns <- list()
counter <- 1
max.par <- nrow(Cmatrix) - 2
if(!is.null(max.pars)) max.par <- max.pars
if(messages == T) cat(paste("Generating Models"))
if(length(pos.cols) < max.par){
max.par <- length(pos.cols)
}
for(i in 1:max.par){
if(messages == T) cat(".")
foo <- combn(pos.cols, i)
# Models are described by a vector of the columns they include
for(j in 1:ncol(foo)){
eqns[[counter]] <- as.vector(foo[,j])
counter <- counter + 1
}
}
if(length(eqns) <= 1000) x <- 50
if(length(eqns) > 1000) x <- 500
if(length(eqns) > 10000) x <- 5000
mod.results <- vector(mode = "list", length = length(eqns))
num.pars <- dev <- aic <- vector(length=length(eqns))
counter <- 0
if(!is.null(Cmatrix)){
if(is.character(Cmatrix[1, 1])){
class(Cmatrix) <- "numeric"
}
}
i <- 1
test.mat <- as.matrix(Cmatrix[, c(1, eqns[[i]])])
temp.mod <- glm(data$mean ~ test.mat, weights = data$SE ^ - 2)
temp.mod$coef
is.na(temp.mod$coef)
mod.results <- mod.results[1:counter]
num.pars <- num.pars[1:counter]
dev <-  dev[1:counter]
aic <- aic[1:counter]
## need to report the number of models thrown out due to
## high covariance ~ singularity
if(messages == T){
if(i > counter){
cat(paste("\n", i - (counter - 1),
" models were removed due to high covariances \n",
"or linear relationships between predictor variables.  \n", "The remaining ",
counter - 1, " models have been evaluated.\n\n", sep = ""))
}
}
aicc <- aic + (((2 * num.pars) * (num.pars + 1)) /
(nrow(data) - num.pars))
daicc <- aicc - min(aicc)
# this code correctly produces akaike weights
waic <- (exp(-.5 * daicc)) / (sum(exp(-.5 * daicc)))
new.waic <- waic
new.waic.names <- eqns[as.numeric(names(mod.results))]
# so now we have a copy of the waics to play with
new.vars <- matrix(0,(ncol(Cmatrix)-1),2)
new.vars[,1] <- colnames(Cmatrix)[2:ncol(Cmatrix)]
for(i in 1:nrow(new.vars)){
for(j in 1:length(new.waic)){
if((i+1) %in% new.waic.names[[j]]){
new.vars[i,2] <- as.numeric(new.vars[i,2]) + new.waic[j]
}
}
}
# lets calculate the 95% probability set of models
best.models <- list()
counter <- i <- 0
good.model.waics <- vector()
while(counter < model.sum){
i <- i + 1
counter <- counter + waic[order(waic, decreasing = T, na.last = F)][i]
good.model.waics[i] <- waic[order(waic, decreasing = T, na.last = F)][i]
}
best.models.ind <- order(waic, decreasing = T, na.last = F)[1:i]
best.models <- mod.results[best.models.ind]
if(messages == T){
cat(paste("\nAICc weights were used to select the minimum number of models ",
"whose weights sum \nto greater than ",
model.sum * 100, "% this model set includes ", length(best.models),
" model(s)\n", sep = ""))
}
#lets calculate variable importance
#which equations are being used
best.eqns <- eqns[as.numeric(names(best.models))]
best.eqns.w <- waic[sort(best.models.ind)]
# now we need to print the model weighted averages and SE
# lets make a matrix of the calculated values under each model
par.est <- matrix(0, length(best.eqns), ncol(Cmatrix) + 2)
colnames(par.est) <- c('eqn', colnames(Cmatrix), 'mw')
par.est[, 1] <- names(best.models)
par.est[, 2] <- 1
# now we need a 1 or 0  if the parameter is in the eqn
for(i in 1:nrow(par.est)){
bar <- as.numeric(par.est[i, 1])
par.est[i, eqns[[bar]] + 1] <- 1
}
# now replace 1's with the parameter estimate for each variable
for(i in 1:nrow(par.est)){
bar <- best.models[[i]]$coefficients[-2]
counter <- 0
for(j in 2:ncol(par.est)){
if(par.est[i, j] == 1){
counter <- counter + 1
par.est[i, j] <- bar[counter]
}
}
}
# add in the aicw
# best.models has eqn lookup in waic
names(waic) <- names(mod.results)
for(i in 1:nrow(par.est)){
par.est[i, ncol(par.est)] <- waic[names(waic) == par.est[i, 1]]
}
# recalculate model waic to sum to 1
par.est[, 'mw'] <- as.numeric(par.est[, 'mw']) /
sum(as.numeric(par.est[, 'mw']))
# calculate the model weighted parameter estimates
par.est <- rbind(par.est, rep(0,ncol(par.est)))
for(i in 2:(ncol(par.est)-1)){
par.est[nrow(par.est), i] <- sum(as.numeric(par.est[1:nrow(par.est)-1, i]) *
as.numeric(par.est[1:nrow(par.est)-1, 'mw']))
}
par.est[nrow(par.est), 1] <- 'mw.avg'
# now lets calculate the unconditional variances as proposed in burnham and
# anderson 2002 pg 162
# so lets duplicate table par.est to use to fill in our values
var.est <- par.est
for(i in 1:length(eqns)){
# generate the matrix for the current model
test.mat <- as.matrix(Cmatrix[, c(1, eqns[[i]])])
# fit the model weight is equal to the inverse of the square of the SE
temp.mod <- glm(data$mean ~ test.mat, weights = data$SE ^ - 2)
# this if statement will bypass a model with a singularity
# 1 NA will be generated for the line mean any additional are sign of sing.
if(sum(is.na(temp.mod$coef)) < 2){
counter <- counter + 1
# name model results as eqns
mod.results[[counter]] <- temp.mod
names(mod.results)[counter] <- i
# record the number of parameters in the model
num.pars[counter] <- length(mod.results[[counter]]$coefficients) - 1
# record the residual deviances
dev[counter] <- mod.results[[counter]]$dev
# record the AIC of the models
aic[counter] <- mod.results[[counter]]$aic
}
if(messages == T) if(i / x == round(i / x)) cat(paste("\n", i))
}
# Get rid of excess preallocation
mod.results <- mod.results[1:counter]
num.pars <- num.pars[1:counter]
dev <-  dev[1:counter]
aic <- aic[1:counter]
## need to report the number of models thrown out due to
## high covariance ~ singularity
if(messages == T){
if(i > counter){
cat(paste("\n", i - (counter - 1),
" models were removed due to high covariances \n",
"or linear relationships between predictor variables.  \n", "The remaining ",
counter - 1, " models have been evaluated.\n\n", sep = ""))
}
}
aicc <- aic + (((2 * num.pars) * (num.pars + 1)) /
(nrow(data) - num.pars))
daicc <- aicc - min(aicc)
# this code correctly produces akaike weights
waic <- (exp(-.5 * daicc)) / (sum(exp(-.5 * daicc)))
new.waic <- waic
new.waic.names <- eqns[as.numeric(names(mod.results))]
# so now we have a copy of the waics to play with
new.vars <- matrix(0,(ncol(Cmatrix)-1),2)
new.vars[,1] <- colnames(Cmatrix)[2:ncol(Cmatrix)]
for(i in 1:nrow(new.vars)){
for(j in 1:length(new.waic)){
if((i+1) %in% new.waic.names[[j]]){
new.vars[i,2] <- as.numeric(new.vars[i,2]) + new.waic[j]
}
}
}
# lets calculate the 95% probability set of models
best.models <- list()
counter <- i <- 0
good.model.waics <- vector()
while(counter < model.sum){
i <- i + 1
counter <- counter + waic[order(waic, decreasing = T, na.last = F)][i]
good.model.waics[i] <- waic[order(waic, decreasing = T, na.last = F)][i]
}
best.models.ind <- order(waic, decreasing = T, na.last = F)[1:i]
best.models <- mod.results[best.models.ind]
if(messages == T){
cat(paste("\nAICc weights were used to select the minimum number of models ",
"whose weights sum \nto greater than ",
model.sum * 100, "% this model set includes ", length(best.models),
" model(s)\n", sep = ""))
}
#lets calculate variable importance
#which equations are being used
best.eqns <- eqns[as.numeric(names(best.models))]
best.eqns.w <- waic[sort(best.models.ind)]
# now we need to print the model weighted averages and SE
# lets make a matrix of the calculated values under each model
par.est <- matrix(0, length(best.eqns), ncol(Cmatrix) + 2)
colnames(par.est) <- c('eqn', colnames(Cmatrix), 'mw')
par.est[, 1] <- names(best.models)
par.est[, 2] <- 1
# now we need a 1 or 0  if the parameter is in the eqn
for(i in 1:nrow(par.est)){
bar <- as.numeric(par.est[i, 1])
par.est[i, eqns[[bar]] + 1] <- 1
}
# now replace 1's with the parameter estimate for each variable
for(i in 1:nrow(par.est)){
bar <- best.models[[i]]$coefficients[-2]
counter <- 0
for(j in 2:ncol(par.est)){
if(par.est[i, j] == 1){
counter <- counter + 1
par.est[i, j] <- bar[counter]
}
}
}
# add in the aicw
# best.models has eqn lookup in waic
names(waic) <- names(mod.results)
for(i in 1:nrow(par.est)){
par.est[i, ncol(par.est)] <- waic[names(waic) == par.est[i, 1]]
}
# recalculate model waic to sum to 1
par.est[, 'mw'] <- as.numeric(par.est[, 'mw']) /
sum(as.numeric(par.est[, 'mw']))
# calculate the model weighted parameter estimates
par.est <- rbind(par.est, rep(0,ncol(par.est)))
for(i in 2:(ncol(par.est)-1)){
par.est[nrow(par.est), i] <- sum(as.numeric(par.est[1:nrow(par.est)-1, i]) *
as.numeric(par.est[1:nrow(par.est)-1, 'mw']))
}
par.est[nrow(par.est), 1] <- 'mw.avg'
# now lets calculate the unconditional variances as proposed in burnham and
# anderson 2002 pg 162
# so lets duplicate table par.est to use to fill in our values
var.est <- par.est
nrow(var.est)
i <- 1
best.models[[which(names(best.models) ==
var.est[i, 1])]])
cov(best.models[[which(names(best.models) ==
var.est[i, 1])]])
vcov(best.models[[which(names(best.models) ==
var.est[i, 1])]])
diag(vcov(best.models[[which(names(best.models) ==
var.est[i, 1])]]))
summary(best.models[[1]])
names(best.models)
var.est
foo <- var.est
View(foo)
names(best.models)
var.est[i, 1]
best.models[[which(names(best.models) ==
var.est[i, 1])]]
foo <- best.models[[which(names(best.models) == var.est[i, 1])]]
foo
vcov(foo)
help("vcov")
foobar <- best.eqns[[32]]
foobar <- best.eqns[32]
foobar <- best.eqns[1]
summary(foobar)
foobar <- best.eqns[[1]]
foobar <- best.models[[2]]
summary(foobar)
diag(vcov(best.models[[which(names(best.models) ==
var.est[i, 1])]],
complete = FALSE))
load("/Users/hblackmon/Desktop/Dropbox/gitrepos/r-packages/LCAdata/data/lca.data.rda")
load("/Users/hblackmon/Desktop/Dropbox/gitrepos/r-packages/LCAdata/data/lca.data.rda")
names(lca.data)
foo <- lca.data[[28]]
View(foo)
load("/Users/hblackmon/Desktop/Dropbox/gitrepos/r-packages/LCAdata/data/lca.data.rda")
names(lca.dat)
names(lca.data)
foo <- lca.dat[[28]]
foo <- lca.data[[28]]
View(foo)
weight <- rbind(lca.data[[28]],
lca.data[[29]])
View(weight)
load("/Users/hblackmon/Desktop/Dropbox/gitrepos/r-packages/LCAdata/data/lca.data.rda")
weight <- rbind(lca.data[[28]],
lca.data[[29]])
locule.fruit <- rbind(lca.data[[33]],
lca.data[[35]])
fruits.cm <- rbind(lca.data[[38]],
lca.data[[40]])
height <- rbind(lca.data[[43]],
lca.data[[44]])
spread <- rbind(lca.data[[48]],
lca.data[[49]])
help("write.csv")
setwd("~/Desktop/Dropbox/projects/SAGA2/manuscript-unrecog-env/data/enviro.var")
setwd("~/Desktop/Dropbox/projects/SAGA2/manuscript-unrecog-env/data/enviro.var/tomato")
write.csv(weight, file="weight.csv", row.names=F)
write.csv(locule.fruit, file="locule.fruit.csv", row.names=F)
write.csv(fruits.cm, file="fruits.cm.csv", row.names=F)
write.csv(height, file="height.csv", row.names=F)
write.csv(spread, file="spread.csv", row.names=F)
.312*sqrt(105)
sqrt(1-.312^2)
3.197/0.95
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/teaching/expdes/hw-labs/data")
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/teaching/expdes/hw-labs/data")
dat.m <- read.csv("gnatocerus.male.csv")
dat.m <- read.csv("gnatocerus.male.csv")
mod1 <- lm(dat.m$mating.attempts ~ dat.m$horn)
mod2 <- lm(dat.m$mating.attempts ~ dat.m$horn * dat.m$body)
mod1$fitted.values
summary(mod1)
logLik.lm(mod1)
logLik(mod1)
logLik(mod2)
logLik(mod1) / logLik(mod2)
hist(rnorm(100))
hist(rnorm(100))
help(lm)
setwd("~/Desktop/Dropbox/gitrepos/coleoguy.github.io/teaching/expdes/hw-labs/data")
dat.m <- read.csv("gnatocerus.male.csv")
dat.f <- read.csv("gnatocerus.female.csv")
fit1 <- lm(dat.m$horn~dat.m$body)
names(fit1)
fit1$residuals == fit1[[2]]
all(fit1$residuals == fit1[[2]])
