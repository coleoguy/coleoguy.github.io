n.tails <- 1
message <- T
rm(list=ls()[-c(21,6,13,8,12,18,15,14)])
##### testing inputs #####
if(class(tree) != 'phylo') {stop('tree must be class phylo')}
if(!is.data.frame(data) & ncol(data) == 3){stop('data should be a dataframe with 3 columns\n(tip labels, cont data, discrete data)')}
if(class(mc) != 'numeric' | round(mc) != mc | mc < 1){stop('mc should be a numeric positive integer integer')}
if(!is.null(drop.state)) if(!drop.state %in% c(1,2)){stop('drop.state must be NULL, or numeric 1 or 2')}
if(!sum(mat == c(0,0,1,0)) == 4 & !sum(mat == c(0,1,1,0)) == 4 & !sum(mat == c(0,2,1,0)) == 4){
stop('mat must be a vector of the form c(0,0,1,0), c(0,1,1,0), or c(0,2,1,0)')
}
if((!pi %in% c('equal', 'estimated'))[1]){
if(!is.numeric(pi)) stop('pi must be equal, estimated or a vector of length 2\nwith probabilities for the state of the discrete character at the root')
if(length(pi) != 2 | sum(pi) != 1) stop('pi must be equal, estimated or a vector of length 2\nwith probabilities for the state of the discrete character at the root')
}
if(n.tails != 1 & n.tails != 2){stop('n.tails should be numeric 1 or 2')}
##### create named vector for disc trait for all taxa #####
dt.vec <- data[, 3]
names(dt.vec) <- data[, 1]
##### create named vector for cont trait taxa not in derived state #####
if(!is.null(drop.state)){
ct.data <- data[(data[, 3] != drop.state),]
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
}else{
ct.data <- data
ct.vec <- as.numeric(ct.data[, 2])
names(ct.vec) <- ct.data[, 1]
}
if(sum(is.na(ct.vec)) > 0 | sum(is.na(dt.vec)) > 0){
stop('There exists missing trait data for some species in the phylogeny.\n
Please remove such taxa from the tree.')
}
#### ASR for the continuous trait  ####
anc.states.cont.trait <- anc.ML(tree, ct.vec, model = "BM")
anc.state.dt <- make.simmap(tree, dt.vec,
model = matrix(mat,2),
nsim = 100,
pi = pi,
Q = 'mcmc',
message = T)
observed.anc.cond <- list()
null.anc.cond <- list()
observed.anc.cond <- list()
null.anc.cond <- list()
for(j in 1:100){
observed.anc.cond[[j]] <- exctractAncestral(current.map = anc.state.dt[[j]],
anc.states.cont.trait)
#######
# current.map <-  anc.state.dt[[j]]
# #### Parse simmap to get producing nodes ####
# # the mapped edge object has time spent in a state in
# # two columns so only branches with a change have an entry
# # in both columns
# #######
# # gets branches with transitions
# ss_nodes <- current.map$mapped.edge[, 1] > 0 &
#   current.map$mapped.edge[, 2] > 0
#
# # this returns the node pairs describing a branch with transitions
# wanted_branches <- ss_nodes[ss_nodes == T]
# wanted_nodes <- names(wanted_branches)
#
#
# if(sum(mat) > 1){
#   # for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
#   producing.nodes12 <- c()
#   producing.nodes21 <-c()
#   trans.maps <- current.map$maps[ss_nodes == T]
#   # now we take the rootward node of each branch and get rid of duplicates
#   wanted_nodes <- gsub(",.*", "", wanted_nodes)
#   ##### Just realized we can do this with describe.simmap :(
#   ##### But i dont want to change it, it would require match function
#   for(i in 1:length(wanted_nodes)){
#     if(names(trans.maps[[i]])[1] == '1'){
#       producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
#     }else if(names(trans.maps[[i]])[1] == '2'){
#       producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
#     }
#   }
#
#   producing.nodes12 <- unique(producing.nodes12)
#   producing.nodes21 <- unique(producing.nodes21)
#
#
#   ##### get estimated ancestral conditions ######
#   observed.anc.cond[[j]] <- list('12' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
#                                                                     producing.nodes12],
#                                  '21' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
#                                                                     producing.nodes21])
########
}
# this takes a stochastic map and continuous trait
exctractAncestral <- function(current.map, anc.states.cont.trait){
#### Parse simmap to get producing nodes ####
# the mapped edge object has time spent in a state in
# two columns so only branches with a change have an entry
# in both columns
#######
# gets branches with transitions
ss_nodes <- current.map$mapped.edge[, 1] > 0 &
current.map$mapped.edge[, 2] > 0
# this returns the node pairs describing a branch with transitions
wanted_branches <- ss_nodes[ss_nodes == T]
wanted_nodes <- names(wanted_branches)
# for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
producing.nodes12 <- c()
producing.nodes21 <-c()
trans.maps <- current.map$maps[ss_nodes == T]
# now we take the rootward node of each branch and get rid of duplicates
wanted_nodes <- gsub(",.*", "", wanted_nodes)
##### Just realized we can do this with describe.simmap :(
##### But i dont want to change it, it would require match function
for(i in 1:length(wanted_nodes)){
if(names(trans.maps[[i]])[1] == '1'){
producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
}else if(names(trans.maps[[i]])[1] == '2'){
producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
}
}
producing.nodes12 <- unique(producing.nodes12)
producing.nodes21 <- unique(producing.nodes21)
##### get estimated ancestral conditions ######
observed.anc.cond <- list('12' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
producing.nodes12],
'21' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
producing.nodes21])
return(observed.anc.cond)
}
for(j in 1:100){
observed.anc.cond[[j]] <- exctractAncestral(current.map = anc.state.dt[[j]],
anc.states.cont.trait)
#######
# current.map <-  anc.state.dt[[j]]
# #### Parse simmap to get producing nodes ####
# # the mapped edge object has time spent in a state in
# # two columns so only branches with a change have an entry
# # in both columns
# #######
# # gets branches with transitions
# ss_nodes <- current.map$mapped.edge[, 1] > 0 &
#   current.map$mapped.edge[, 2] > 0
#
# # this returns the node pairs describing a branch with transitions
# wanted_branches <- ss_nodes[ss_nodes == T]
# wanted_nodes <- names(wanted_branches)
#
#
# if(sum(mat) > 1){
#   # for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
#   producing.nodes12 <- c()
#   producing.nodes21 <-c()
#   trans.maps <- current.map$maps[ss_nodes == T]
#   # now we take the rootward node of each branch and get rid of duplicates
#   wanted_nodes <- gsub(",.*", "", wanted_nodes)
#   ##### Just realized we can do this with describe.simmap :(
#   ##### But i dont want to change it, it would require match function
#   for(i in 1:length(wanted_nodes)){
#     if(names(trans.maps[[i]])[1] == '1'){
#       producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
#     }else if(names(trans.maps[[i]])[1] == '2'){
#       producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
#     }
#   }
#
#   producing.nodes12 <- unique(producing.nodes12)
#   producing.nodes21 <- unique(producing.nodes21)
#
#
#   ##### get estimated ancestral conditions ######
#   observed.anc.cond[[j]] <- list('12' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
#                                                                     producing.nodes12],
#                                  '21' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
#                                                                     producing.nodes21])
########
}
iter = 10
j <- 1
current.map = anc.state.dt[[j]]
# if(sum(mat) > 1){
nulldist <- matrix(NA,iter,2)
colnames(nulldist) <- c('12','21')
n <- 1
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
null.disc.trait <- sim.char(phy = tree,
par = anc.state.dt$Q,
model = 'discrete',
root = sample(c(1,2),1))
anc.state.dt$Q
current.map$Q
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
null.disc.trait
unique(null.disc.trait)
length(unique(null.disc.trait))>1
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
if(length(unique(null.disc.trait))>1) good.sim <- T
}
rownames(null.disc.trait)
names(null.disc.trait)
help(make.simmap)
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
model = current.map$Q,
nsim = 1,
pi = pi,
message = F)
current.map$Q
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
plot(sim.anc.state.dt)
# if(sum(mat) > 1){
nulldist <- list()
n <- 1
nulldist[[n]] <- exctractAncestral(current.map = sim.anc.state.dt,
anc.states.cont.trait = anc.states.cont.trait)
nulldist[[1]]
# }else{
#   nulldist <- vector(length = iter)
# }
for(n in 1:iter){
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
if(length(unique(null.disc.trait))>1) good.sim <- T
}
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
nulldist[[n]] <- exctractAncestral(current.map = sim.anc.state.dt,
anc.states.cont.trait = anc.states.cont.trait)
}
CreateNull <- function(tree,                     # a tree type phylo
iter,                     # number of simulations for null
current.map,             # for Q-matrix
anc.states.cont.trait){   # ancestral state reconstruction for continuous
# if(sum(mat) > 1){
nulldist <- list()
# }else{
#   nulldist <- vector(length = iter)
# }
for(n in 1:iter){
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
if(length(unique(null.disc.trait))>1) good.sim <- T
}
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree = tree,
null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
nulldist[[n]] <- exctractAncestral(current.map = sim.anc.state.dt,
anc.states.cont.trait = anc.states.cont.trait)
}
return(nulldist)
}
source('~/Desktop/Dropbox/projects/ancCond/analyses/functions.R')
source('~/Desktop/Dropbox/projects/ancCond/analyses/functions.R')
hist(density(rexp(n=1000, rate=.5)))
rexp(n=1000, rate=.5)
plot(density(rexp(n=1000, rate=.5)))
plot(density(rexp(n=10000, rate=.5)))
plot(density(rexp(n=100000, rate=.5)))
plot(density(rexp(n=100000, rate=.15)))
plot(density(rexp(n=100000, rate=1)))
plot(density(rexp(n=100000, rate=2)))
library(diversitree)
help("make.mkn")
x <- c(1, 4, 5)
x <- c("jeff", "lewis")
x <- c(T, F, TRUE, FALSE)
x <- c(1, 3, "Jen")
x <- c(T, 3, "Jen")
?matrix
matrix(, 2, 3)
x <- matrix(, 2, 3)
x[2, 3]
x[2, 3] <- 234745
x[2, 3]
x[2, ]
x[2, ] <- 3
x
x[2, ] <- c(1,2,3,4)
x <- c(T, 3, "Jen")
x[3]
gexp <- rnorm(100)
help(sample)
covpos <- sample(x=c(T,F), n=100, replace=T)
covpos <- sample(x=c(T,F), size=100, replace=T)
dat <- data.frame(gexp, covpos)
View(dat)
mylist <- list(dat, gexp, covpos)
mylist[[1]]
mylist[[1]][2,3]
mylist[[1]][3,2]
gexp[covpos]
c(1,3,4,6,7,8) > 4
c("A","B") == "A"
for(i in 1:10){
print(i)
}
log(2)
sqrt(log(2))
library(devtools)
install_github("radamsRHA/PRDATR")
library(PRDATR) # Load package
setwd("~/Desktop")
dat <- read.csv("Microplastic Summer and Fall Counts.csv")
times <- locs <- mats <- c()
times <- unique(dat$Season)
locs <- unique(dat$Sample.Site)
mats <- unique(dat$Material)
dat <- read.csv("Microplastic Summer and Fall Counts.csv",
as.is=T)
times <- unique(dat$Season)
locs <- unique(dat$Sample.Site)
mats <- unique(dat$Material)
preds <- list(times, locs, mats)
par(mfcol=c(2,2))
j <-1
k <- 1
cur.dat <- preds[j]
cur.dat <- preds[[j]]
vals <- matrix(,9,3)
vals <- matrix(,9,3)
cur.vars <- preds[[j]]
for(k in 1:3){
vals[, k] <- dat$Amount[dat[,j] == cur.vars[k]]
}
View(vals)
j <- 2
vals <- matrix(,9,3)
cur.vars <- preds[[j]]
for(k in 1:3){
vals[, k] <- dat$Amount[dat[,j] == cur.vars[k]]
}
View(vals)
library(beeswarm)
dat <- read.csv("Microplastic Summer and Fall Counts.csv",
as.is=T)
times <- unique(dat$Season)
locs <- unique(dat$Sample.Site)
mats <- unique(dat$Material)
preds <- list(times, locs, mats)
par(mfcol=c(2,2))
beeswarm(vals)
beeswarm(vals)
names(preds)
names(preds) <- c("time", "location", "material")
beeswarm(vals, main=names(preds)[j])
times <- unique(dat$Season)
locs <- unique(dat$Sample.Site)
mats <- unique(dat$Material)
preds <- list(times, locs, mats)
names(preds) <- c("time", "location", "material")
par(mfcol=c(2,2))
for(j in 1:3){
vals <- matrix(,9,3)
cur.vars <- preds[[j]]
for(k in 1:3){
vals[, k] <- dat$Amount[dat[,j] == cur.vars[k]]
}
beeswarm(vals, main=names(preds)[j])
}
help(bswarn)
bswarm
beeswarm(dat$Amount~dat$Season)
library(beeswarm)
dat <- read.csv("Microplastic Summer and Fall Counts.csv",
as.is=T)
times <- unique(dat$Season)
locs <- unique(dat$Sample.Site)
mats <- unique(dat$Material)
preds <- list(times, locs, mats)
names(preds) <- c("time", "location", "material")
par(mfcol=c(2,2))
for(j in 1:3){
beeswarm(dat$Amount~dat[,j])
}
library(beeswarm)
dat <- read.csv("Microplastic Summer and Fall Counts.csv",
as.is=T)
times <- unique(dat$Season)
locs <- unique(dat$Sample.Site)
mats <- unique(dat$Material)
preds <- list(times, locs, mats)
names(preds) <- c("time", "location", "material")
par(mfcol=c(2,2))
for(j in 1:3){
beeswarm(dat$Amount~dat[,j],
ylab="amount",
main=names(preds)[j],
xlab="")
}
lm(dat$Amount ~ dat$Season + dat$Sample.Site + dat$Material)
fit <- lm(dat$Amount ~ dat$Season + dat$Sample.Site + dat$Material)
summary(fit)
library(evobiR)
SlidingWindow(FUN = mean,
data = 1:100,
step = 5,
window = 10)
library(devtools)
install_github('coleoguy/evobir', build_vignettes = T)
setwd("~/Desktop/test/databases")
shiny::runApp()
runApp()
runApp()
runApp()
setwd("~/Desktop/test/databases")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shinytest::recordTest("~/Desktop/test/databases")
runApp()
runApp()
runApp()
runApp('plantapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('vertapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('vertapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('plantapp.R')
runApp('invertapp.R')
runApp('invertapp.R')
runApp('invertapp.R')
runApp('invertapp.R')
runApp('invertapp.R')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/plantapp.R')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/vert/vertapp.R')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/vert/app.R')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/plant')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/vert')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/invert')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/plant')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/plant')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/vert')
runApp('~/Desktop/Dropbox/gitrepos/coleoguy.github.io/tos/databases/vert')
