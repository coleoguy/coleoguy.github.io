---
title: "Creating Functions"
author: "Johnathan Lo"
date: "March 8, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Functions

A function is an operation that takes one or more inputs (arguments) and transforms them into some output. By now, you've probably already used a bunch of functions. In fact, you've probably strung those functions together to create an output that you specifically desire, aka a script. But sometimes, it can be a pain to run the entire script over and over manually, so we wrap it in a function. The last step in a function you write will usuall be a call of the function return which returns the items you want to keep from your run.

Lets start with a super simple example let right a function that calculates the mean:

```{r}
MyMean <- function(x){
  total <- sum(x)
  avg <- total/length(x)
  return(avg)
}
```

Try writing a function that calculates the mode of a series of numbers.


Now that you've done that lets try writing a more complex function. Lets start with find the distance between two points

```{r}
find_distance <- function(a, b){
  n <- length(a)
  i <- 1
  s <- vector(mode = "numeric", length = n)
  while (i<=n)
  {
    s[i] <- b[i] - a[i]
    i <- i+1
  }
  s <- s^2
  distance <- sqrt(sum(s))
  return (distance)
}

a <- c(0,0,0,0,0,0)
b <- c(1,1,1,1,1,1)
a_to_b <- find_distance(a,b)
print(a_to_b)

```

A side note: if you want to use your own functions without having to include them in your main script every single time, save the function to a separate file and use the r command source() to load the function into your namespace. 

```{r}
#source("find_distance.r")
a <- c(0,0,0,0,0,0)
b <- c(1,1,1,1,1,1)
a_to_b <- find_distance(a,b)
print(a_to_b)
```

Try writing your own function to find the mode of a vector of arbitrary length and type.

##Recursive functions

Functions can call other functions, that much is clear. But a function can also call itself. This is called recursion. Below is an example using the Fibonacci sequence, in which each number is the sum of the previous two numbers. 

Ex: 

```{r}
fibonacci <- function(n){
  if (n==0)
  {
    return(0)
  }
  if (n==1)
  {
    return(1)
  }
  else
  {
    return (fibonacci(n-1)+fibonacci(n-2))
  }
}

print(fibonacci(0))
print(fibonacci(1))
print(fibonacci(2))
print(fibonacci(3))
print(fibonacci(4))
print(fibonacci(5))
print(fibonacci(6))

```

Try running this function with n = 20. Bonus points if you can time it. How long does it take? Why do you think this happens?

Write a function that uses recursion to find the greatest common denominator of two numbers. 

Bonus: Write a function for the Fibonacci sequence that does NOT use recursion. Add a timer and run it for n: [0,20], and do the same for the recursive Fibonacci function. Graph runtime vs n.

##Debugging

If other people are going to be using your function, it pays to implement error handling. This can help people figure out why their input isn't working (although if you comment and document your code well enough, this shouldn't be an issue).

There are many base R functions for handling errors. The simplest and most useful are warning() and stop().

Warning() allows your function to continue, but issue a warning depending on a condition. Stop() stops the function entirely if a condition is fulfilled.

```{r}
find_distance <- function(a, b){
  if(length(a)!=length(b))
  {
    warning('Warning: The vectors are not the same length\n')
  }
  n <- length(a)
  i <- 1
  s <- vector(mode = "numeric", length = n)
  while (i<=n)
  {
    s[i] <- b[i] - a[i]
    i <- i+1
  }
  s <- s^2
  distance <- sqrt(sum(s))
  return (distance)
}

a <- c(0,0,0,0,0)
b <- c(1,1,1,1,1,1)
a_to_b <- find_distance(a,b)
print(a_to_b)

```

Sometimes, you may want to stop the function from running entirely:

```{r}
fibonacci <- function(n){
  if (n>25)
  {
    stop('n is too large. Potential stack overflow.\n')
  }
  if (n==0)
  {
    return(0)
  }
  if (n==1)
  {
    return(1)
  }
  else
  {
    return (fibonacci(n-1)+fibonacci(n-2))
  }
}

# print(fibonacci(50))
print(fibonacci(24))


```

